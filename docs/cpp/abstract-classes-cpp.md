---
description: 'Дополнительные сведения: абстрактные классы (C++)'
title: Абстрактные классы (C++)
ms.date: 02/18/2021
helpviewer_keywords:
- classes [C++], abstract
- base classes [C++], abstract classes [C++]
- abstract classes [C++]
- derived classes [C++], abstract classes [C++]
ms.openlocfilehash: 8a20e988cb0c0a134fd2ebb83382d81c838bcf23
ms.sourcegitcommit: 5efc34c2b98d4d0d3e41aec38b213f062c19d078
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "101844498"
---
# <a name="abstract-classes-c"></a>Абстрактные классы (C++)

Абстрактные классы используются в качестве обобщенных концепций, на основе которых можно создавать более конкретные производные классы. Нельзя создать объект типа абстрактного класса. Однако можно использовать указатели и ссылки на абстрактные типы классов.

Абстрактный класс создается путем объявления по крайней мере одной чистой виртуальной функции члена. Это виртуальная функция, объявленная с помощью синтаксиса чистого описателя ( `= 0` ). Классы, производные от абстрактного класса, должны реализовывать чисто виртуальную функцию; в противном случае они также будут абстрактными.

Рассмотрим пример, представленный в [виртуальных функциях](../cpp/virtual-functions.md). Класс `Account` создан для того, чтобы предоставлять общие функции, но объекты типа `Account` имеют слишком общий характер для практического применения. Это означает `Account` хороший кандидат для абстрактного класса:

```cpp
// deriv_AbstractClasses.cpp
// compile with: /LD
class Account {
public:
   Account( double d );   // Constructor.
   virtual double GetBalance();   // Obtain balance.
   virtual void PrintBalance() = 0;   // Pure virtual function.
private:
    double _balance;
};
```

Единственное различие между этим и предыдущим объявлениями состоит в том, что функция `PrintBalance` объявлена со спецификатором чисто виртуальной функции pure (`= 0`).

## <a name="restrictions-on-abstract-classes"></a>Ограничения на использование абстрактных классов

Абстрактные классы нельзя использовать для:

- переменных и данных членов;

- типов аргументов;

- типов возвращаемых функциями значений;

- типов явных преобразований.

Если конструктор абстрактного класса вызывает чисто виртуальную функцию, прямо или косвенно, результат не определен. Однако конструкторы и деструкторы абстрактных классов могут вызывать другие функции-члены.

## <a name="defined-pure-virtual-functions"></a>Определенные чистые виртуальные функции

Чистые виртуальные функции в абстрактных классах могут быть *определены* или иметь реализацию. Вызывать эти функции можно только с помощью полного синтаксиса:

*abstract — имя класса*::*Function-Name*()

Определенные чистые виртуальные функции полезны при проектировании иерархий классов, базовые классы которых содержат чистые виртуальные деструкторы. Это обусловлено тем, что деструкторы базового класса всегда вызываются во время уничтожения объекта. Рассмотрим следующий пример.

```cpp
// deriv_RestrictionsOnUsingAbstractClasses.cpp
// Declare an abstract base class with a pure virtual destructor.
// It's the simplest possible abstract class.
class base
{
public:
    base() {}
    virtual ~base() = 0 {}; // pure virtual, and defined!
};

class derived : public base
{
public:
    derived() {}
    ~derived() {}
};

int main()
{
    derived aDerived; // destructor called when it goes out of scope
}
```

В примере показано определение `~base()` встроенного, но его можно также определить за пределами класса с помощью `base::~base() {}` .

Когда объект `aDerived` выходит из области действия, `derived` вызывается деструктор класса. Компилятор создает код для неявного вызова деструктора класса `base` после `derived` деструктора. Пустая реализация чисто виртуальной функции `~base` гарантирует, что для функции существует хотя бы определенная реализация. Без него компоновщик создает неразрешенную ошибку внешнего символа для неявного вызова.

> [!NOTE]
> В предыдущем примере чистая виртуальная функция `base::~base` вызывается неявно из `derived::~derived`. Кроме того, можно явно вызывать чистые виртуальные функции, используя полное имя функции-члена. Такие функции должны иметь реализацию, или вызов приводит к ошибке во время компоновки.

## <a name="see-also"></a>См. также раздел

[Наследование](../cpp/inheritance-cpp.md)
